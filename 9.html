<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>üëÅüëÅüëÅ</title><style>body {
        margin: 0;
        height: 100vh;
        display: flex;
        align-items: center;
        background: lightblue;
      }

      #app {
        margin: auto;
      }

      #stream {
        /*visibility: hidden;*/
        position: absolute;
        top: 0;
        left: 0;
      }

      #overlay {
        position: absolute;
        border: 2px solid blue;
        height: 10px;
        width: 10px;
        transition: all 0.3s;
      }</style></head><body><video id="stream" width="200" height="150" preload autoplay loop muted></video><div 
id="overlay"></div><canvas id="app"></canvas><script src="assets/face_api.js"></script><script>(async () => {
        let DEBUG = false;
        let CONTROL_MODE = 'webcam';
        // stream: a image handled somewhere else
        // webcam: handle creating a webcam feed
        // mouse: just use the mouse
        let LAYOUT_MODE = 'big';
        // one: one BIG eye
        // big: a few huge eyes
        // small: heaps of little eyes
        const humanFaceWidth = 0.20;

        const eyeColors = ['#a29bfe', '#74b9ff', '#ff7675', '#fab1a0', '#81ecec', '#55efc4'];
        const eyeMargin = 20;
        const mouseDepth = 300;
        const maxDistanceFactor = 10;
        const irisRadiusFactor = 3 / 5;
        const pupilRadiusFactor = 1 / 3;
        const highlightRadiusFactor = 1 / 8;
        const highlightOffsetFactor = 1/5;

        const streamElement = document.getElementById('stream');
        const overlay = document.getElementById('overlay');
        const {fov: fovDeg, id: configId, dpi} = JSON.parse(localStorage.getItem('eyes-config')) || {fov: 50, id: 'unset', dpi: 80};
        const cameraFov = fovDeg * Math.PI / 180;
        const detector = new faceapi.TinyFaceDetectorOptions({size: 416});

        // dpi -> dpcm
        // dpcm -> dpm
        const pixelsPerMeter = (dpi / 2.56) * 100;
        let stream;
        let height = 0;
        let width = 0;
        let eyes = [[]];
        let eyeRadius = 0;
        let irisRadius = 0;
        let pupilRadius = 0;
        let highlightRadius = 0;
        let highlightOffset = 0;
        let lastRender = performance.now();
        let renderStart = performance.now();
        let detectionTime = 0;
        let maxDistance = 100;
        let dest = {
          x: 0,
          y: 0,
          z: 0
        };
        let started = false;

        let canvas = document.getElementById('app');
        let ctx = canvas.getContext('2d');

        window.addEventListener('resize', initLayout);

        // App fns
        function initLayout() {
          if(!DEBUG) {
            streamElement.style.visibility = 'hidden';
            overlay.style.display = 'none';
          }
          let docHeight = document.body.offsetHeight;
          let docWidth = document.body.offsetWidth;
          if(LAYOUT_MODE === 'one') {
            eyes = [[{
              x: docWidth/2,
              y: docHeight/2,
              color: pickRandom(eyeColors)
            }]];
            eyeRadius = Math.min(docHeight, docWidth)/2 - eyeMargin * 2;
          } else {
            if(LAYOUT_MODE === 'big') eyeRadius = 200;
            else eyeRadius = 60;
            const nX = Math.floor((docWidth - eyeMargin) / (eyeRadius*2 + eyeMargin));
            const nY = Math.floor((docHeight - eyeMargin) / (eyeRadius*2 + eyeMargin));
            const docMarginX = (docWidth - (nX * (eyeRadius*2 + eyeMargin) - eyeMargin)) / 2; // Subtract the rendered area from doc size, then half
            const docMarginY = (docHeight - (nY * (eyeRadius*2 + eyeMargin) - eyeMargin)) / 2;
            for(let y = 0; y < nY; y++) {
              eyes[y] = [];
              for(let x = 0; x < nX; x++) {
                eyes[y][x] = {
                  x: docMarginX + eyeRadius + x * (2 * eyeRadius + eyeMargin),
                  y: docMarginY + eyeRadius + y * (2 * eyeRadius + eyeMargin),
                  color: pickRandom(eyeColors)
                }
              }
            }
          }
          irisRadius = irisRadiusFactor * eyeRadius;
          pupilRadius = pupilRadiusFactor * eyeRadius;
          highlightRadius = highlightRadiusFactor * eyeRadius;
          highlightOffset = highlightOffsetFactor * eyeRadius;

          maxDistance = maxDistanceFactor  * eyeRadius;

          height = canvas.height = docHeight;
          width = canvas.width = docWidth;
        }
        function initControl() {
          switch (CONTROL_MODE) {
            case 'mouse':
              window.addEventListener('mousemove', mouseEvent);
              window.addEventListener('dragover', mouseEvent);
              window.addEventListener('touchstart', e => {
                mouseEvent(e.changedTouches[0])
              });
              window.addEventListener('touchmove', e => {
                mouseEvent(e.changedTouches[0])
              });
              streamElement.width = 0;
              overlay.style.display = 'none';
              break;
            case 'webcam':
              initVideo();
              break;
            case 'stream':
              streamStart();
              break;
            default:
              console.error(`Unknown control mode ${CONTROL_MODE}, falling back to mouse`);
              CONTROL_MODE = 'mouse';
              initControl(); // Eh, just run it again.
          }
        }
        async function initVideo() {
          try {
            stream = await navigator.mediaDevices.getUserMedia({video: true});
            console.log('Successfully obtained video stream')
          } catch (err) {
            console.log('Failed to get webcam, falling back to mouse', err);
            CONTROL_MODE = 'mouse';
            initControl();
          }
          streamElement.srcObject = stream;
          await faceapi.nets.tinyFaceDetector.loadFromUri('assets');
          streamElement.addEventListener('playing', streamStart);
        }
        function streamStart() {
          if(started) console.error('Playing, but already started!');
          started = true;
          detect();
        }
        function mouseEvent(e) {
          dest.x = e.pageX;
          dest.y = e.pageY;
          dest.z = mouseDepth;
        }

        // Generic Utils
        function pickRandom(arr) {
          return arr[Math.floor(Math.random() * arr.length)];
        }
        function pythagoras(...numbers) {
          return Math.sqrt(numbers.reduce((a, b) => a + b ** 2, 0))
        }
        function clamp(val, min, max) {
          return Math.min(max, Math.max(min, val));
        }

        // Render fns
        function render() {
          renderStart = performance.now();
          ctx.clearRect(0, 0, width, height);
          eyes.forEach(r => r.forEach(eye => renderEye(eye)));
          if(DEBUG) renderDebug();
          lastRender = performance.now();
          requestAnimationFrame(render);
        }
        function renderEye({x: eyeX, y: eyeY, color}) {
          let deltaX = clamp(dest.x - eyeX, -maxDistance, maxDistance);
          let deltaY = clamp(dest.y - eyeY, -maxDistance, maxDistance);

          let distX = pythagoras(deltaX, dest.z);
          let distY = pythagoras(deltaY, dest.z);
          let ratioX = (eyeRadius / 1.2) / distX;
          let ratioY = (eyeRadius / 1.2) / distY;

          let offsetX = deltaX * ratioX;
          let offsetY = deltaY * ratioY;
          // console.log(ratioX, ratioY);

          // clip to eye area
          ctx.save();
          ctx.beginPath();
          ctx.ellipse(eyeX, eyeY, eyeRadius, eyeRadius, 0, 0, 2 * Math.PI);
          ctx.clip();

          // eye
          ctx.fillStyle = 'white';
          ctx.beginPath();
          ctx.ellipse(eyeX, eyeY, eyeRadius, eyeRadius, 0, 0, 2 * Math.PI);
          ctx.fill();

          // iris
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.ellipse(eyeX + offsetX, eyeY + offsetY,
            irisRadius - Math.abs(offsetX * eyeRadius / 4000), // width
            irisRadius - Math.abs(offsetY * eyeRadius / 4000), // height
            0, 0, 2 * Math.PI);
          ctx.fill();

          // pupil
          ctx.fillStyle = 'black';
          ctx.beginPath();
          ctx.ellipse(eyeX + (offsetX * 1.15), eyeY + (offsetY * 1.15),
            pupilRadius - Math.abs(offsetX * eyeRadius / 3000), // width
            pupilRadius - Math.abs(offsetY * eyeRadius / 3000), // height
            0, 0, 2 * Math.PI);
          ctx.fill();

          // highlight
          ctx.fillStyle = 'white';
          ctx.beginPath();
          ctx.ellipse(eyeX + (offsetX * 1.2) + highlightOffset, eyeY + (offsetY * 1.2) - highlightOffset, highlightRadius, highlightRadius, 0, 0, 2 * Math.PI);
          ctx.fill();

          ctx.restore();

          if(DEBUG) {
            dot(eyeX, eyeY);
            dot(eyeX + offsetX, eyeY + offsetY, 2, '#F00')
          }
        }
        function dot(x, y, size = 2, color = '#00F') {
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.ellipse(x, y, size, size, 0, 0, 2 * Math.PI);
          ctx.fill();
        }
        function renderDebug() {
          dot(dest.x, dest.y, 5);
          `Dest: ${Math.round(dest.x)}, ${Math.round(dest.y)}, ${Math.round(dest.z)}
          Document: ${width} x ${height}
          DPI: ${dpi} (${pixelsPerMeter}px/m), display is ${pixelsPerMeter * width / 100}cm wide
          FOV: ${fovDeg} degrees
          Using device config: ${configId}
          FPS: ${Math.round(1 / ((performance.now() - lastRender) / 1000))} (${performance.now() - renderStart}ms)
          Detection time: ${detectionTime}ms`
              .split('\n').forEach((l, i) => {
            ctx.fillText(l.trim(), streamElement.width || 10, (i + 1) * 20)
          })
        }

        // Facial recognition!
        async function detect() {
          let detectStart = performance.now();
          const detection = await faceapi.detectSingleFace(streamElement, detector);
          if (detection) {
            // console.log(detection.box)
            let {box} = detection;
            let scale = streamElement.width / streamElement.videoWidth;
            overlay.style.top = box.y * scale + 'px';
            overlay.style.left = box.x * scale + 'px';
            overlay.style.height = box.height * scale + 'px';
            overlay.style.width = box.width * scale + 'px';
          }
          if (detection)
            transformDetection(detection);
          detectionTime = performance.now() - detectStart;
          setTimeout(detect, 0);
        }
        function transformDetection({box, imageHeight, imageWidth}) {
          // Shift above screen
          // Scale with width/distance
          // (de)amplify movement
          let boxY = box.y + box.height/2;
          let boxX = box.x + box.width/2;
          let boxCenteredX = -(boxX - imageWidth/2);
          let boxCenteredY = boxY - imageHeight/2;

          // Calculate depth
          let faceAngle = cameraFov / (imageWidth/box.width); // Width in radians
          let distance = humanFaceWidth / Math.tan(faceAngle); // distance in m
          let distancePx = distance * pixelsPerMeter;

          let fromCenterX = boxCenteredX * 4;
          let fromCenterY = boxCenteredY * 4;
          // console.log(fromCenterX, fromCenterY);
          // let scaleX = width / streamElement.videoWidth;
          // let scaleY = height / streamElement.videoHeight;
          // let boxCenterX = boxX + box.width / 2;
          // let boxCenterY = boxY + box.height / 2;
          // let scaledX = width - (scaleX * boxCenterX); // Flip position, mirror webcam
          // let scaledY = boxCenterY * scaleY;
          // let fromCenterX = scaledX - width / 2;
          // let fromCenterY = scaledY - height / 2;
          dest = {
            x: fromCenterX + width/2,
            y: fromCenterY,
            z: distancePx
          };
        }

        initLayout();
        render();
        initControl();
      })();</script></body></html>